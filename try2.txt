<div id="address-container">
    @{
        var addressList = Model.Addresses.ToList(); // Conversion explicite en List
        var addressTypes = ViewBag.AddressTypes as List<NotifApps.Models.AddressType>; // Types possibles
    }

    @for (int i = 0; i < addressList.Count; i++)
    {
        <div class="form-group d-flex align-items-center justify-content-between">
            <div class="flex-fill me-2">
                <label class="text-black me-2">Type d'adresse</label>
                <select name="addresses[@i].Type" class="form-control">
                    <option value="" disabled>Sélectionnez...</option>
                    @foreach (var type in addressTypes)
                    {
                        if (addressList[i].Type == type.TypeName)
                        {
                            <option value="@type.TypeName" selected>@type.TypeName</option>
                        }
                        else
                        {
                            <option value="@type.TypeName">@type.TypeName</option>
                        }
                    }
                </select>
            </div>
            <div class="flex-fill me-2">
                <label class="text-black me-2">Adresse</label>
                <input type="text" name="addresses[@i].Value" 
                       class="form-control" 
                       value="@addressList[i].Value" 
                       placeholder="Saisissez une adresse" />
            </div>
            <div class="flex-fill me-2">
                <i type="button" class="fas fa-plus m-md-3 mx-5"></i>
            </div>
        </div>
    }
</div>



<div id="address-container">
    @if (Model.Addresses != null && ViewBag.AddressTypes != null)
    {
        var addressTypes = ViewBag.AddressTypes as List<NotifApps.Models.AddressType>; // Les types possibles

        for (int i = 0; i < Model.Addresses.Count; i++)
        {
            <div class="form-group d-flex align-items-center justify-content-between">
                <div class="flex-fill me-2">
                    <label class="text-black me-2">Type d'adresse</label>
                    <select name="addresses[@i].Type" class="form-control">
                        <option value="" disabled>Sélectionnez...</option>
                        @foreach (var type in addressTypes)
                        {
                            if (Model.Addresses[i].Type == type.TypeName)
                            {
                                <option value="@type.TypeName" selected>@type.TypeName</option>
                            }
                            else
                            {
                                <option value="@type.TypeName">@type.TypeName</option>
                            }
                        }
                    </select>
                </div>
                <div class="flex-fill me-2">
                    <label class="text-black me-2">Adresse</label>
                    <input type="text" name="addresses[@i].Value" 
                           class="form-control" 
                           value="@Model.Addresses[i].Value" 
                           placeholder="Saisissez une adresse" />
                </div>
                <div class="flex-fill me-2">
                    <i type="button" class="fas fa-plus m-md-3 mx-5"></i>
                </div>
            </div>
        }
    }
</div>











<div id="address-container">
    @if (Model.Addresses != null && ViewBag.AddressTypes != null)
    {
        var addressesList = Model.Addresses.ToList();
        var addressTypes = ViewBag.AddressTypes as List<NotifApps.Models.AddressType>; // Ensure type casting

        for (int i = 0; i < addressesList.Count; i++)
        {
            <div class="form-group mb-3">
                <label for="addressType">Type d'adresse</label>
                <select name="addresses[@i].Type" class="form-control">
                    @foreach (var type in addressTypes)
                    {
                        var isSelected = addressesList[i].Type == type.Type ? "selected" : ""; // Determine selection
                        <option value="@type.Type" @isSelected>@type.Type</option>
                    }
                </select>

                <label for="addressValue">Adresse</label>
                <input type="text" name="addresses[@i].Value" class="form-control" value="@addressesList[i].Value" />
            </div>
        }
    }
</div>



<div id="address-container">
    @{
        var addressesList = Model.Addresses.ToList();
        var addressTypes = ViewBag.AddressTypes as List<NotifApps.Models.AddressType>; // Types possibles
    }
    @for (int i = 0; i < addressesList.Count; i++)
    {
        <div class="form-group mb-3">
            <label for="addressType">Type d'adresse</label>
            <select name="addresses[@i].Type" class="form-control">
                @foreach (var type in addressTypes)
                {
                    <option value="@type.Type"
                            @(addressesList[i].Type == type.Type ? "selected" : "")>
                        @type.Type
                    </option>
                }
            </select>

            <label for="addressValue">Adresse</label>
            <input type="text" name="addresses[@i].Value" class="form-control" value="@addressesList[i].Value" />
        </div>
    }
</div>











using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Rendering;
using Microsoft.EntityFrameworkCore;
using NotifApps.Models;
using OfficeOpenXml;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace NotifApps.Controllers
{
    public class ApplicatifController : Controller
    {
        private readonly NotifdbContext _context;

        public ApplicatifController(NotifdbContext context)
        {
            _context = context;
        }

        // INDEX: List of all applicatifs
        public async Task<IActionResult> Index()
        {
            var applicatifs = await _context.Applicatifs
                .Include(a => a.Addresses)
                .ToListAsync();

            return View(applicatifs);
        }

        // GEET POST
        public IActionResult Create()
        {
            ViewBag.AddressTypes = _context.AddressTypes.ToList();
            return View();
        }

        // CREATE POST
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(Applicatif applicatif, List<Address> addresses)
        {
            if (ModelState.IsValid)
            {
                using (var transaction = await _context.Database.BeginTransactionAsync())
                {
                    try
                    {
                        _context.Add(applicatif);
                        await _context.SaveChangesAsync();

                        // Handle addresses
                        foreach (var address in addresses)
                        {
                            var existingAddress = await _context.Addresses
                                .FirstOrDefaultAsync(a => a.Type == address.Type && a.Value == address.Value && a.AppId == applicatif.AppId);

                            if (existingAddress == null)
                            {
                                address.AppId = applicatif.AppId; 
                                _context.Addresses.Add(address);
                            }
                        }
                        await _context.SaveChangesAsync();

                        // Commit the transaction
                        await transaction.CommitAsync();

                        return RedirectToAction(nameof(Index));
                    }
                    catch (Exception)
                    {
                        await transaction.RollbackAsync();
                        throw; 
                    }
                }
            }

            ViewBag.AddressTypes = _context.AddressTypes.ToList();
           return View(applicatif);
        }

        // GET: Applicatifs/Edit/5
        public async Task<IActionResult> Edit(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var applicatif = await _context.Applicatifs
                .Include(a => a.Addresses)
                .FirstOrDefaultAsync(m => m.AppId == id);

            if (applicatif == null)
            {
                return NotFound();
            }

            // Charger les types d'adresse pour la liste déroulante
            ViewBag.AddressTypes = await _context.AddressTypes.ToListAsync();

            return View(applicatif);
        }

        // POST: Applicatifs/Edit/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(int id, Applicatif applicatif, List<Address> addresses)
        {
            if (id != applicatif.AppId)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                using (var transaction = await _context.Database.BeginTransactionAsync())
                {
                    try
                    {
                        // Mise à jour de l'applicatif
                        _context.Update(applicatif);
                        await _context.SaveChangesAsync();

                        // Vérifier que les types d'adresse sont valides
                        var validTypes = await _context.AddressTypes.Select(t => t.Type).ToListAsync();

                        foreach (var address in addresses)
                        {
                            if (!validTypes.Contains(address.Type))
                            {
                                ModelState.AddModelError("", $"Le type d'adresse '{address.Type}' n'est pas valide.");
                                return View(applicatif);
                            }
                        }

                        // Récupérer les adresses existantes
                        var existingAddresses = await _context.Addresses
                            .Where(a => a.AppId == applicatif.AppId)
                            .ToListAsync();

                        // Supprimer les adresses obsolètes
                        var addressesToRemove = existingAddresses
                            .Where(existing => !addresses.Any(a => a.Type == existing.Type && a.Value == existing.Value))
                            .ToList();
                        _context.Addresses.RemoveRange(addressesToRemove);

                        // Ajouter ou mettre à jour les adresses
                        foreach (var address in addresses)
                        {
                            var existingAddress = existingAddresses
                                .FirstOrDefault(a => a.Type == address.Type && a.Value == address.Value);

                            if (existingAddress == null)
                            {
                                // Nouvelle adresse
                                address.AppId = applicatif.AppId;
                                _context.Addresses.Add(address);
                            }
                            else
                            {
                                // Mettre à jour si nécessaire
                                existingAddress.Value = address.Value;
                            }
                        }

                        await _context.SaveChangesAsync();

                        await transaction.CommitAsync();

                        return RedirectToAction(nameof(Index));
                    }
                    catch (Exception)
                    {
                        await transaction.RollbackAsync();
                        throw;
                    }
                }
            }

            // Recharge les types en cas d'erreur
            ViewBag.AddressTypes = await _context.AddressTypes.ToListAsync();
            return View(applicatif);
        }


        private bool ApplicatifExists(int id)
        {
            return _context.Applicatifs.Any(e => e.AppId == id);
        }

        // DETAILS: GET method
        public async Task<IActionResult> Details(int id)
        {
            var applicatif = await _context.Applicatifs
                .Include(a => a.Addresses)

                .Include(a => a.EquipeApplicatifs) 
                .ThenInclude(ea => ea.Equipe) 
                .FirstOrDefaultAsync(a => a.AppId == id);

            if (applicatif == null)
            {
                return NotFound();
            }

            return View(applicatif);
        }

        // RATTACHER EQUIPE A APPLICATIF
        public IActionResult AttacheEquipe(int id)
        {
            var applicatif = _context.Applicatifs.Find(id);
            var equipes = _context.Equipes.ToList(); // Get all teams
            ViewBag.ApplicatifId = id;

            // Define criticality options
            ViewBag.CriticiteOptions = new List<string> { "P0", "P1", "P2", "P3" };

            return View(equipes);
        }

        //POST ATTACH
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> SaveEquipe(int applicatifId, int equipeId, string criticiteNom)
        {
            var applicatif = await _context.Applicatifs.FindAsync(applicatifId);
            var equipe = await _context.Equipes.FindAsync(equipeId);

            if (applicatif != null && equipe != null)// check si equipe est null ou pas 
            {
                var equipeApplicatif = new EquipeApplicatif
                {
                    AppId = applicatifId,
                    EquipeId = equipeId,
                    CriticiteNom = criticiteNom 
                };

                _context.Add(equipeApplicatif);
                await _context.SaveChangesAsync();
                return RedirectToAction(nameof(Details), new { id = applicatifId });
            }

            return NotFound();
        }
        // GET: Applicatif/EditCriticite
        [HttpGet]
        public async Task<IActionResult> EditCriticite(int applicatifId, int equipeId)
        {
            var equipeApplicatif = await _context.EquipeApplicatifs
                .FirstOrDefaultAsync(ea => ea.AppId == applicatifId && ea.EquipeId == equipeId);

            if (equipeApplicatif == null)
            {
                return NotFound();
            }

            ViewBag.CriticiteOptions = new List<string> { "P0", "P1", "P2", "P3" };
            return View(equipeApplicatif);
        }
        // POST: Applicatif/EditCriticite
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> EditCriticite(int applicatifId, int equipeId, string criticiteNom)
        {
            var equipeApplicatif = await _context.EquipeApplicatifs
                .FirstOrDefaultAsync(ea => ea.AppId == applicatifId && ea.EquipeId == equipeId);

            if (equipeApplicatif == null)
            {
                
                return NotFound();
            }
            equipeApplicatif.CriticiteNom = criticiteNom;

            if (ModelState.IsValid)
            {
                try
                {
                    _context.Update(equipeApplicatif);
                    await _context.SaveChangesAsync();
                    return RedirectToAction("Details", new { id = applicatifId });
                }
                catch (DbUpdateConcurrencyException)
                {                    if (!EquipeApplicatifExists(applicatifId, equipeId))
                    {
                        return NotFound();
                    }
                    else
                    {
                        throw;
                    }
                }
            }
            ViewBag.CriticiteOptions = new List<string> { "P0", "P1", "P2", "P3" };
            return View(equipeApplicatif);
        }

        // Méthode pour vérifier l'existence de l'association équipe-applicatif
        private bool EquipeApplicatifExists(int applicatifId, int equipeId)
        {
            return _context.EquipeApplicatifs.Any(e => e.AppId == applicatifId && e.EquipeId == equipeId);
        }

        // GET: Delete
        public async Task<IActionResult> Delete(int? id)
        {
            if (id == null)
            {
                return NotFound();
            }

            var applicatif = await _context.Applicatifs
                .Include(a => a.Addresses)
                .Include(a => a.EquipeApplicatifs)
                .FirstOrDefaultAsync(a => a.AppId == id);

            if (applicatif == null)
            {
                return NotFound();
            }

            return View(applicatif);
        }

        // DELETE: POST method
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            var applicatif = await _context.Applicatifs
                .Include(a => a.Addresses)
                .Include(a => a.EquipeApplicatifs) 
                .FirstOrDefaultAsync(a => a.AppId == id);

            if (applicatif == null) return NotFound();

            _context.Addresses.RemoveRange(applicatif.Addresses);

            var equipesApplicatifs = await _context.EquipeApplicatifs
                .Where(ea => ea.AppId == id)
                .ToListAsync();

            _context.EquipeApplicatifs.RemoveRange(equipesApplicatifs);

            _context.Applicatifs.Remove(applicatif);

            await _context.SaveChangesAsync();
            return RedirectToAction(nameof(Index));
        }


        // POST: Applicatifs/DetachEquipe
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DetachEquipe(int applicatifId, int equipeId)
        {
            var equipeApplicatif = await _context.EquipeApplicatifs
                .FirstOrDefaultAsync(ea => ea.AppId == applicatifId && ea.EquipeId == equipeId);

            if (equipeApplicatif == null)
            {
                return NotFound();
            }

            _context.EquipeApplicatifs.Remove(equipeApplicatif);
            await _context.SaveChangesAsync();
            return RedirectToAction(nameof(Details), new { id = applicatifId });
        }



    }

}


<div id="address-container">
                        @{
                            var addressesList = Model.Addresses.ToList();
                            var addressTypes = ViewBag.AddressTypes as List<AddressType>; // Types possibles
                        }
                        @for (int i = 0; i < addressesList.Count; i++)
                        {
                            <div class="form-group mb-3">
                                <label>Type d'adresse</label>
                                <select name="addresses[@i].Type" class="form-control">
                                    @foreach (var type in addressTypes)
                                    {
                                        <option value="@type.Type"
                                                @(addressesList[i].Type= =type.Type ? "selected" : "" )>
                                            @type.Type
                                        </option>
                                    }
                                </select>
                                <label>Adresse</label>
                                <input type="text" name="addresses[@i].Value" class="form-control" value="@addressesList[i].Value" />
                            </div>
                        }
                    </div>

Gravité	Code	Description	Projet	Fichier	Ligne	État de la suppression
Erreur	CS1061	'AddressType' ne contient pas de définition pour 'Type' et aucune méthode d'extension accessible 'Type' acceptant un premier argument de type 'AddressType' n'a été trouvée (une directive using ou une référence d'assembly est-elle manquante ?)	NotifApps	C:\Users\AG881981\source\repos\NotifApps\NotifApps\Views\Applicatif\Edit.cshtml	47	Actif


Gravité	Code	Description	Projet	Fichier	Ligne	État de la suppression
Erreur	CS1061	'AddressType' ne contient pas de définition pour 'Type' et aucune méthode d'extension accessible 'Type' acceptant un premier argument de type 'AddressType' n'a été trouvée (une directive using ou une référence d'assembly est-elle manquante ?)	NotifApps	C:\Users\AG881981\source\repos\NotifApps\NotifApps\Controllers\ApplicatifController.cs	130	Actif

using System;
using System.Collections.Generic;

#nullable disable

namespace NotifApps.Models
{
    public partial class Address
    {
        public int AddressId { get; set; }
        public int? AppId { get; set; }
        public string Type { get; set; }
        public string Value { get; set; }

        public virtual Applicatif App { get; set; }
    }
}
